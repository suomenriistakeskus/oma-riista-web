
package fi.riista.integration.luke_import.model.v1_0;

import java.util.HashMap;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAnyAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.namespace.QName;
import com.kscs.util.jaxb.Copyable;
import com.kscs.util.jaxb.PartialCopyable;
import com.kscs.util.jaxb.PropertyTree;
import com.kscs.util.jaxb.PropertyTreeUse;
import fi.riista.integration.support.DayAndMonthAdapter;
import org.joda.time.LocalDate;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;


/**
 * <p>Java class for _Metsästyspäivien_olosuhdetiedotType complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="_Metsästyspäivien_olosuhdetiedotType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="_Päivämäärä" type="{http://www.abbyy.com/FlexiCapture/Schemas/Export/Hirvitietokortti.xsd}DayAndMonth"/&gt;
 *         &lt;element name="_Metsästysaika" type="{http://www.w3.org/2001/XMLSchema}float"/&gt;
 *         &lt;element name="_Lumen_syvyys" type="{http://www.w3.org/2001/XMLSchema}int"/&gt;
 *         &lt;element name="_Metsästystapa" type="{http://www.w3.org/2001/XMLSchema}int"/&gt;
 *         &lt;element name="_Metsästäjiä" type="{http://www.w3.org/2001/XMLSchema}int"/&gt;
 *         &lt;element name="_Metsästyskoiria" type="{http://www.w3.org/2001/XMLSchema}int"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;anyAttribute namespace='http://www.abbyy.com/FlexiCapture/Schemas/Export/AdditionalFormData.xsd'/&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "_Mets\u00e4stysp\u00e4ivien_olosuhdetiedotType", namespace = "http://www.abbyy.com/FlexiCapture/Schemas/Export/Hirvitietokortti.xsd", propOrder = {
    "startDate",
    "huntingTime",
    "snowDepth",
    "huntingMethod",
    "numberOfHunters",
    "numberOfHounds"
})
public class MooseDataCardHuntingDay implements Cloneable, Copyable, PartialCopyable, ToString2
{

    @XmlElement(name = "_P\u00e4iv\u00e4m\u00e4\u00e4r\u00e4", required = true, type = String.class)
    @XmlJavaTypeAdapter(DayAndMonthAdapter.class)
    protected LocalDate startDate;
    @XmlElement(name = "_Mets\u00e4stysaika", required = true, type = Float.class, nillable = true)
    protected Float huntingTime;
    @XmlElement(name = "_Lumen_syvyys", required = true, type = Integer.class, nillable = true)
    protected Integer snowDepth;
    @XmlElement(name = "_Mets\u00e4stystapa", required = true, type = Integer.class, nillable = true)
    protected Integer huntingMethod;
    @XmlElement(name = "_Mets\u00e4st\u00e4ji\u00e4", required = true, type = Integer.class, nillable = true)
    protected Integer numberOfHunters;
    @XmlElement(name = "_Mets\u00e4styskoiria", required = true, type = Integer.class, nillable = true)
    protected Integer numberOfHounds;
    @XmlAnyAttribute
    private Map<QName, String> otherAttributes = new HashMap<QName, String>();

    /**
     * Generated by copy-constructor plugin, JAXB requires public no-arg constructor.
     * 
     */
    public MooseDataCardHuntingDay() {
        // Generated by copy-constructor plugin, JAXB requires public no-arg constructor.
    }

    /**
     * Instantiates a MooseDataCardHuntingDay copying the state of another MooseDataCardHuntingDay
     * 
     * @param _other
     *     The original MooseDataCardHuntingDay from which to copy state.
     */
    public MooseDataCardHuntingDay(final MooseDataCardHuntingDay _other) {
        this.startDate = _other.startDate;
        this.huntingTime = _other.huntingTime;
        this.snowDepth = _other.snowDepth;
        this.huntingMethod = _other.huntingMethod;
        this.numberOfHunters = _other.numberOfHunters;
        this.numberOfHounds = _other.numberOfHounds;
    }

    /**
     * Instantiates a MooseDataCardHuntingDay copying the state of another MooseDataCardHuntingDay
     * 
     * @param _propertyTreeUse
     *     Meaning of the {@link PropertyPath}: Exclude or include members contained in property path.
     * @param _propertyTree
     *     A restricting {@link PropertyPath} that defines which nodes of the source object tree should actually be copied.
     * @param _other
     *     The original MooseDataCardHuntingDay from which to copy state.
     */
    public MooseDataCardHuntingDay(final MooseDataCardHuntingDay _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        final PropertyTree startDatePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("startDate"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(startDatePropertyTree!= null):((startDatePropertyTree == null)||(!startDatePropertyTree.isLeaf())))) {
            this.startDate = _other.startDate;
        }
        final PropertyTree huntingTimePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("huntingTime"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(huntingTimePropertyTree!= null):((huntingTimePropertyTree == null)||(!huntingTimePropertyTree.isLeaf())))) {
            this.huntingTime = _other.huntingTime;
        }
        final PropertyTree snowDepthPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("snowDepth"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(snowDepthPropertyTree!= null):((snowDepthPropertyTree == null)||(!snowDepthPropertyTree.isLeaf())))) {
            this.snowDepth = _other.snowDepth;
        }
        final PropertyTree huntingMethodPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("huntingMethod"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(huntingMethodPropertyTree!= null):((huntingMethodPropertyTree == null)||(!huntingMethodPropertyTree.isLeaf())))) {
            this.huntingMethod = _other.huntingMethod;
        }
        final PropertyTree numberOfHuntersPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("numberOfHunters"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(numberOfHuntersPropertyTree!= null):((numberOfHuntersPropertyTree == null)||(!numberOfHuntersPropertyTree.isLeaf())))) {
            this.numberOfHunters = _other.numberOfHunters;
        }
        final PropertyTree numberOfHoundsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("numberOfHounds"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(numberOfHoundsPropertyTree!= null):((numberOfHoundsPropertyTree == null)||(!numberOfHoundsPropertyTree.isLeaf())))) {
            this.numberOfHounds = _other.numberOfHounds;
        }
    }

    /**
     * Gets the value of the startDate property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public LocalDate getStartDate() {
        return startDate;
    }

    /**
     * Sets the value of the startDate property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setStartDate(LocalDate value) {
        this.startDate = value;
    }

    /**
     * Gets the value of the huntingTime property.
     * 
     * @return
     *     possible object is
     *     {@link Float }
     *     
     */
    public Float getHuntingTime() {
        return huntingTime;
    }

    /**
     * Sets the value of the huntingTime property.
     * 
     * @param value
     *     allowed object is
     *     {@link Float }
     *     
     */
    public void setHuntingTime(Float value) {
        this.huntingTime = value;
    }

    /**
     * Gets the value of the snowDepth property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getSnowDepth() {
        return snowDepth;
    }

    /**
     * Sets the value of the snowDepth property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setSnowDepth(Integer value) {
        this.snowDepth = value;
    }

    /**
     * Gets the value of the huntingMethod property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getHuntingMethod() {
        return huntingMethod;
    }

    /**
     * Sets the value of the huntingMethod property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setHuntingMethod(Integer value) {
        this.huntingMethod = value;
    }

    /**
     * Gets the value of the numberOfHunters property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getNumberOfHunters() {
        return numberOfHunters;
    }

    /**
     * Sets the value of the numberOfHunters property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setNumberOfHunters(Integer value) {
        this.numberOfHunters = value;
    }

    /**
     * Gets the value of the numberOfHounds property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getNumberOfHounds() {
        return numberOfHounds;
    }

    /**
     * Sets the value of the numberOfHounds property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setNumberOfHounds(Integer value) {
        this.numberOfHounds = value;
    }

    /**
     * Gets a map that contains attributes that aren't bound to any typed property on this class.
     * 
     * <p>
     * the map is keyed by the name of the attribute and 
     * the value is the string value of the attribute.
     * 
     * the map returned by this method is live, and you can add new attribute
     * by updating the map directly. Because of this design, there's no setter.
     * 
     * 
     * @return
     *     always non-null
     */
    public Map<QName, String> getOtherAttributes() {
        return otherAttributes;
    }

    public String toString() {
        final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE2;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
        {
            LocalDate theStartDate;
            theStartDate = this.getStartDate();
            strategy.appendField(locator, this, "startDate", buffer, theStartDate, (this.startDate!= null));
        }
        {
            Float theHuntingTime;
            theHuntingTime = this.getHuntingTime();
            strategy.appendField(locator, this, "huntingTime", buffer, theHuntingTime, (this.huntingTime!= null));
        }
        {
            Integer theSnowDepth;
            theSnowDepth = this.getSnowDepth();
            strategy.appendField(locator, this, "snowDepth", buffer, theSnowDepth, (this.snowDepth!= null));
        }
        {
            Integer theHuntingMethod;
            theHuntingMethod = this.getHuntingMethod();
            strategy.appendField(locator, this, "huntingMethod", buffer, theHuntingMethod, (this.huntingMethod!= null));
        }
        {
            Integer theNumberOfHunters;
            theNumberOfHunters = this.getNumberOfHunters();
            strategy.appendField(locator, this, "numberOfHunters", buffer, theNumberOfHunters, (this.numberOfHunters!= null));
        }
        {
            Integer theNumberOfHounds;
            theNumberOfHounds = this.getNumberOfHounds();
            strategy.appendField(locator, this, "numberOfHounds", buffer, theNumberOfHounds, (this.numberOfHounds!= null));
        }
        return buffer;
    }

    public MooseDataCardHuntingDay withStartDate(LocalDate value) {
        setStartDate(value);
        return this;
    }

    public MooseDataCardHuntingDay withHuntingTime(Float value) {
        setHuntingTime(value);
        return this;
    }

    public MooseDataCardHuntingDay withSnowDepth(Integer value) {
        setSnowDepth(value);
        return this;
    }

    public MooseDataCardHuntingDay withHuntingMethod(Integer value) {
        setHuntingMethod(value);
        return this;
    }

    public MooseDataCardHuntingDay withNumberOfHunters(Integer value) {
        setNumberOfHunters(value);
        return this;
    }

    public MooseDataCardHuntingDay withNumberOfHounds(Integer value) {
        setNumberOfHounds(value);
        return this;
    }

    @Override
    public MooseDataCardHuntingDay clone() {
        final MooseDataCardHuntingDay _newObject;
        try {
            _newObject = ((MooseDataCardHuntingDay) super.clone());
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        return _newObject;
    }

    @Override
    public MooseDataCardHuntingDay createCopy() {
        final MooseDataCardHuntingDay _newObject;
        try {
            _newObject = ((MooseDataCardHuntingDay) super.clone());
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        _newObject.startDate = this.startDate;
        _newObject.huntingTime = this.huntingTime;
        _newObject.snowDepth = this.snowDepth;
        _newObject.huntingMethod = this.huntingMethod;
        _newObject.numberOfHunters = this.numberOfHunters;
        _newObject.numberOfHounds = this.numberOfHounds;
        return _newObject;
    }

    @Override
    public MooseDataCardHuntingDay createCopy(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        final MooseDataCardHuntingDay _newObject;
        try {
            _newObject = ((MooseDataCardHuntingDay) super.clone());
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
        final PropertyTree startDatePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("startDate"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(startDatePropertyTree!= null):((startDatePropertyTree == null)||(!startDatePropertyTree.isLeaf())))) {
            _newObject.startDate = this.startDate;
        }
        final PropertyTree huntingTimePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("huntingTime"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(huntingTimePropertyTree!= null):((huntingTimePropertyTree == null)||(!huntingTimePropertyTree.isLeaf())))) {
            _newObject.huntingTime = this.huntingTime;
        }
        final PropertyTree snowDepthPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("snowDepth"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(snowDepthPropertyTree!= null):((snowDepthPropertyTree == null)||(!snowDepthPropertyTree.isLeaf())))) {
            _newObject.snowDepth = this.snowDepth;
        }
        final PropertyTree huntingMethodPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("huntingMethod"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(huntingMethodPropertyTree!= null):((huntingMethodPropertyTree == null)||(!huntingMethodPropertyTree.isLeaf())))) {
            _newObject.huntingMethod = this.huntingMethod;
        }
        final PropertyTree numberOfHuntersPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("numberOfHunters"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(numberOfHuntersPropertyTree!= null):((numberOfHuntersPropertyTree == null)||(!numberOfHuntersPropertyTree.isLeaf())))) {
            _newObject.numberOfHunters = this.numberOfHunters;
        }
        final PropertyTree numberOfHoundsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("numberOfHounds"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(numberOfHoundsPropertyTree!= null):((numberOfHoundsPropertyTree == null)||(!numberOfHoundsPropertyTree.isLeaf())))) {
            _newObject.numberOfHounds = this.numberOfHounds;
        }
        return _newObject;
    }

    @Override
    public MooseDataCardHuntingDay copyExcept(final PropertyTree _propertyTree) {
        return createCopy(_propertyTree, PropertyTreeUse.EXCLUDE);
    }

    @Override
    public MooseDataCardHuntingDay copyOnly(final PropertyTree _propertyTree) {
        return createCopy(_propertyTree, PropertyTreeUse.INCLUDE);
    }

    public static class Select
        extends MooseDataCardHuntingDay.Selector<MooseDataCardHuntingDay.Select, Void>
    {


        Select() {
            super(null, null, null);
        }

        public static MooseDataCardHuntingDay.Select _root() {
            return new MooseDataCardHuntingDay.Select();
        }

    }

    public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
        extends com.kscs.util.jaxb.Selector<TRoot, TParent>
    {

        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> startDate = null;
        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> huntingTime = null;
        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> snowDepth = null;
        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> huntingMethod = null;
        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> numberOfHunters = null;
        private com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> numberOfHounds = null;

        public Selector(final TRoot root, final TParent parent, final String propertyName) {
            super(root, parent, propertyName);
        }

        @Override
        public Map<String, PropertyTree> buildChildren() {
            final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
            products.putAll(super.buildChildren());
            if (this.startDate!= null) {
                products.put("startDate", this.startDate.init());
            }
            if (this.huntingTime!= null) {
                products.put("huntingTime", this.huntingTime.init());
            }
            if (this.snowDepth!= null) {
                products.put("snowDepth", this.snowDepth.init());
            }
            if (this.huntingMethod!= null) {
                products.put("huntingMethod", this.huntingMethod.init());
            }
            if (this.numberOfHunters!= null) {
                products.put("numberOfHunters", this.numberOfHunters.init());
            }
            if (this.numberOfHounds!= null) {
                products.put("numberOfHounds", this.numberOfHounds.init());
            }
            return products;
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> startDate() {
            return ((this.startDate == null)?this.startDate = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "startDate"):this.startDate);
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> huntingTime() {
            return ((this.huntingTime == null)?this.huntingTime = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "huntingTime"):this.huntingTime);
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> snowDepth() {
            return ((this.snowDepth == null)?this.snowDepth = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "snowDepth"):this.snowDepth);
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> huntingMethod() {
            return ((this.huntingMethod == null)?this.huntingMethod = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "huntingMethod"):this.huntingMethod);
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> numberOfHunters() {
            return ((this.numberOfHunters == null)?this.numberOfHunters = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "numberOfHunters"):this.numberOfHunters);
        }

        public com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>> numberOfHounds() {
            return ((this.numberOfHounds == null)?this.numberOfHounds = new com.kscs.util.jaxb.Selector<TRoot, MooseDataCardHuntingDay.Selector<TRoot, TParent>>(this._root, this, "numberOfHounds"):this.numberOfHounds);
        }

    }

}
