package fi.riista.feature.permit.invoice;

import fi.riista.feature.common.entity.BicConverter;
import fi.riista.feature.common.entity.CreditorReference;
import fi.riista.feature.common.entity.IbanConverter;
import fi.riista.feature.common.entity.LifecycleEntity;
import fi.riista.feature.common.money.FinnishBank;
import fi.riista.feature.common.money.FinnishBankAccount;
import fi.riista.feature.organization.address.Address;
import fi.riista.feature.permit.invoice.search.InvoiceDeliveryType;
import fi.riista.feature.permit.invoice.search.InvoiceDisplayState;
import fi.riista.feature.storage.metadata.PersistentFileMetadata;
import fi.riista.validation.XssSafe;
import org.hibernate.validator.constraints.NotBlank;
import org.iban4j.Bic;
import org.iban4j.Iban;
import org.joda.time.LocalDate;

import javax.annotation.Nonnull;
import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Convert;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.OneToOne;
import javax.persistence.Transient;
import javax.validation.Valid;
import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;
import java.math.BigDecimal;
import java.util.EnumSet;
import java.util.Objects;
import java.util.Optional;

import static fi.riista.feature.permit.invoice.InvoiceState.DELIVERED;
import static fi.riista.feature.permit.invoice.InvoiceState.PAID;
import static fi.riista.feature.permit.invoice.InvoiceState.REMINDER;
import static fi.riista.feature.permit.invoice.InvoiceState.VOID;
import static fi.riista.util.DateUtil.today;
import static fi.riista.util.NumberUtils.bigDecimalIsPositive;
import static java.lang.String.format;
import static java.util.Objects.requireNonNull;

// Common data for all invoices
@Entity
@Access(value = AccessType.FIELD)
public class Invoice extends LifecycleEntity<Long> {

    public static final String ID_COLUMN_NAME = "invoice_id";

    private Long id;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, updatable = false)
    private InvoiceType type;

    // Must meet Fivaldi constraints (max 8 digits and must not collide with existing Fivaldi invoice numbers)
    @Column(nullable = false)
    private int invoiceNumber;

    @NotNull
    @Convert(converter = BicConverter.class)
    @Column(length = 11, nullable = false)
    private Bic bic;

    @NotNull
    @Column(length = 18, nullable = false)
    @Convert(converter = IbanConverter.class)
    private Iban iban;

    @NotNull
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private InvoiceState state;

    @NotNull
    @Column(nullable = false)
    private LocalDate invoiceDate;

    @NotNull
    @Column(nullable = false)
    private LocalDate dueDate;

    @Column
    private LocalDate paymentDate;

    @NotNull
    @Column(nullable = false)
    private BigDecimal amount;

    // Corrected amount will be set instead of amount when invoice has transitioned to PAID state.
    @Column
    private BigDecimal correctedAmount;

    // Accumulated money sum from one or multiple account transfers parsed from account statements.
    @Column
    private BigDecimal receivedAmount;

    @NotNull
    @Valid
    @Embedded
    private CreditorReference creditorReference;

    // Recipient's name at the time invoice was created.
    @NotBlank
    @Size(max = 255)
    @Column(nullable = false)
    private String recipientName;

    // Recipient's address at the time invoice was created.
    @NotNull
    @OneToOne(optional = false, fetch = FetchType.LAZY, cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(unique = true, nullable = false)
    private Address recipientAddress;

    @Column(nullable = false, updatable = false)
    private boolean originalDeliveryByEmail;

    @Column(nullable = false)
    private boolean electronicInvoicingEnabled;

    // Unique id for payment.
    @XssSafe
    @Size(max = 255)
    @Column
    private String paytrailPaymentId;

    // This is the same reference number that was sent to the Payment Gateway or the reference number generated by Paytrail.
    @XssSafe
    @Size(max = 255)
    @Column
    private String paytrailSettlementReferenceNumber;

    @NotNull
    @OneToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "file_metadata_id", unique = true, nullable = false)
    private PersistentFileMetadata pdfFileMetadata;

    Invoice() {
        // For Hibernate
    }

    public Invoice(final InvoiceType type, final boolean electronicInvoicingEnabled) {
        this.type = type;
        this.electronicInvoicingEnabled = electronicInvoicingEnabled;
        this.originalDeliveryByEmail = electronicInvoicingEnabled;
    }

    @Transient
    @AssertTrue
    public boolean isMatchBetweenBicAndIban() {
        return Objects.equals(bic, FinnishBank.resolveBic(iban));
    }

    @Transient
    public void updateInvoiceAndDueDate(@Nonnull final LocalDate invoiceDate) {
        this.invoiceDate = requireNonNull(invoiceDate);
        this.dueDate = type.calculateDueDate(invoiceDate);
    }

    @Transient
    private void assertStateTransition(final EnumSet<InvoiceState> allowedFromStates, final InvoiceState toState) {
        if (!allowedFromStates.contains(this.state)) {
            throw new IllegalStateException(format(
                    "Illegal state transition from %s to %s for invoice id=%d", state.name(), toState.name(), id));
        }
    }

    @Transient
    public void setStateReminder() {
        switch (type) {
            case PERMIT_PROCESSING:
                assertStateTransition(EnumSet.of(DELIVERED, REMINDER), REMINDER);
                break;
            case PERMIT_HARVEST:
                assertStateTransition(EnumSet.of(DELIVERED, REMINDER, PAID), REMINDER);
                break;
        }

        if (electronicInvoicingEnabled) {
            throw new IllegalStateException(format(
                    "Cannot transition invoice state to %s when electronic invoicing is enabled for invoice id=%d",
                    REMINDER.name(), this.id));
        }

        this.state = InvoiceState.REMINDER;
    }

    @Transient
    public void disableElectronicInvoicing() {
        if (!electronicInvoicingEnabled) {
            throw new IllegalStateException("Electronic invoicing is already disabled for invoice id=" + id);
        }

        if (type == InvoiceType.PERMIT_PROCESSING) {
            if (state == PAID) {
                throw new IllegalStateException("Cannot disable electronic invoicing for paid processing invoice id=" + id);
            }
        } else if (type == InvoiceType.PERMIT_HARVEST) {
            // If receivedAmount is null then a relating account statement is not yet received
            // => Need to wait for it
            if (state == PAID && receivedAmount == null || !hasRemainingAmount()) {
                throw new IllegalStateException("Cannot disable electronic invoicing for harvest invoice id=" + id);
            }
        }

        this.electronicInvoicingEnabled = false;
    }

    @Transient
    public boolean isReceiptAvailable() {
        switch (type) {
            case PERMIT_PROCESSING:
                return state == PAID;
            case PERMIT_HARVEST:
                return state == PAID || receivedAmount != null;
            default:
                throw new IllegalStateException("Unknown invoice type: " + type);
        }
    }

    @Transient
    public BigDecimal getReceiptAmount() {
        switch (type) {
            case PERMIT_PROCESSING:
                return state == PAID ? amount : BigDecimal.ZERO;
            case PERMIT_HARVEST:
                return Optional
                        .ofNullable(receivedAmount)
                        // If account statement for Paytrail payment not yet received => Use invoice amount
                        .orElseGet(() -> paytrailPaymentId != null ? amount : BigDecimal.ZERO);
        }
        throw new IllegalStateException("Unknown invoice type: " + type);
    }

    @Transient
    public BigDecimal getRemainingAmount() {
        final BigDecimal invoicedAmount = Optional.ofNullable(correctedAmount).orElse(amount);
        return receivedAmount != null ? invoicedAmount.subtract(receivedAmount) : invoicedAmount;
    }

    @Transient
    public boolean hasRemainingAmount() {
        return bigDecimalIsPositive(getRemainingAmount());
    }

    @Transient
    public InvoiceDisplayState getDisplayState() {
        return InvoiceDisplayState.from(state, isDueDateInPast());
    }

    @Transient
    public InvoiceDeliveryType getDeliveryType() {
        return electronicInvoicingEnabled ? InvoiceDeliveryType.ELECTRONIC : InvoiceDeliveryType.MAIL;
    }

    @Transient
    public FinnishBankAccount resolveBankAccountDetails() {
        return FinnishBankAccount.fromIban(iban);
    }

    @Transient
    public boolean isOverdue() {
        switch (type) {
            case PERMIT_PROCESSING:
                return (state == DELIVERED || state == REMINDER) && isDueDateInPast();
            case PERMIT_HARVEST:
                return state != VOID && isDueDateInPast() && hasRemainingAmount();
            default:
                throw new IllegalStateException("Unknown invoice type: " + type);
        }
    }

    @Transient
    public boolean isPaytrailPaymentInitiated() {
        return paytrailPaymentId != null;
    }

    @Transient
    public void setPaid(@Nonnull final LocalDate paymentDate) {
        setState(PAID);
        setPaymentDate(requireNonNull(paymentDate));
    }

    @Transient
    public void setIbanAndBic(@Nonnull final FinnishBankAccount bankAccount) {
        requireNonNull(bankAccount);
        setBic(bankAccount.getBic());
        setIban(bankAccount.getIban());
    }

    private boolean isDueDateInPast() {
        return today().isAfter(dueDate);
    }

    // Accessors -->

    @Override
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Access(value = AccessType.PROPERTY)
    @Column(name = ID_COLUMN_NAME, nullable = false)
    public Long getId() {
        return id;
    }

    @Override
    public void setId(final Long id) {
        this.id = id;
    }

    public InvoiceType getType() {
        return type;
    }

    /* package */ void setType(final InvoiceType type) {
        this.type = type;
    }

    public int getInvoiceNumber() {
        return invoiceNumber;
    }

    public void setInvoiceNumber(final int invoiceNumber) {
        this.invoiceNumber = invoiceNumber;
    }

    public Bic getBic() {
        return bic;
    }

    /* package */ void setBic(final Bic bic) {
        this.bic = bic;
    }

    public Iban getIban() {
        return iban;
    }

    /* package */ void setIban(final Iban iban) {
        this.iban = iban;
    }

    public InvoiceState getState() {
        return state;
    }

    public void setState(final InvoiceState state) {
        this.state = state;
    }

    public LocalDate getInvoiceDate() {
        return invoiceDate;
    }

    /* package */ void setInvoiceDate(final LocalDate invoiceDate) {
        this.invoiceDate = invoiceDate;
    }

    public LocalDate getDueDate() {
        return dueDate;
    }

    /* package */ void setDueDate(final LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public LocalDate getPaymentDate() {
        return paymentDate;
    }

    public void setPaymentDate(final LocalDate paymentDate) {
        this.paymentDate = paymentDate;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(final BigDecimal amount) {
        this.amount = amount;
    }

    public BigDecimal getCorrectedAmount() {
        return correctedAmount;
    }

    public void setCorrectedAmount(final BigDecimal correctedAmount) {
        this.correctedAmount = correctedAmount;
    }

    public BigDecimal getReceivedAmount() {
        return receivedAmount;
    }

    public void setReceivedAmount(final BigDecimal receivedAmount) {
        this.receivedAmount = receivedAmount;
    }

    public CreditorReference getCreditorReference() {
        return creditorReference;
    }

    public void setCreditorReference(final CreditorReference creditorReference) {
        this.creditorReference = creditorReference;
    }

    public String getRecipientName() {
        return recipientName;
    }

    public void setRecipientName(final String recipientName) {
        this.recipientName = recipientName;
    }

    public Address getRecipientAddress() {
        return recipientAddress;
    }

    public void setRecipientAddress(final Address recipientAddress) {
        this.recipientAddress = recipientAddress;
    }

    public boolean isElectronicInvoicingEnabled() {
        return electronicInvoicingEnabled;
    }

    public boolean isOriginalDeliveryByEmail() {
        return originalDeliveryByEmail;
    }

    public String getPaytrailPaymentId() {
        return paytrailPaymentId;
    }

    public void setPaytrailPaymentId(final String paytrailPaymentId) {
        this.paytrailPaymentId = paytrailPaymentId;
    }

    public String getPaytrailSettlementReferenceNumber() {
        return paytrailSettlementReferenceNumber;
    }

    public void setPaytrailSettlementReferenceNumber(final String paytrailSettlementReferenceNumber) {
        this.paytrailSettlementReferenceNumber = paytrailSettlementReferenceNumber;
    }

    public PersistentFileMetadata getPdfFileMetadata() {
        return pdfFileMetadata;
    }

    public void setPdfFileMetadata(final PersistentFileMetadata pdfFileMetadata) {
        this.pdfFileMetadata = pdfFileMetadata;
    }
}
